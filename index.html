<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Jeu Pixel Art 3D Horreur</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
    #info {
      position: absolute;
      color: white;
      font-family: monospace;
      padding: 10px;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
    }
  </style>
</head>
<body>
<div id="info">Pièces ramassées : <span id="score">0</span></div>
<script>
  // Injecter Three.js depuis un CDN compatible GitHub Pages
  const script = document.createElement('script');
  script.src = "https://unpkg.com/three@0.152.2/build/three.min.js";
  script.onload = () => startGame();
  document.head.appendChild(script);

  function startGame() {
    let scene, camera, renderer;
    let player, platforms = [], coins = [];
    let moveLeft = false, moveRight = false, jumping = false;
    let velocityY = 0;
    const gravity = -0.6;
    const jumpPower = 12;
    let score = 0;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.05);
      scene.background = new THREE.Color(0x222222);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 25);
      camera.lookAt(0, 5, 0);

      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x555555);
      scene.add(ambientLight);

      const spotLight = new THREE.SpotLight(0xffffff, 1);
      spotLight.position.set(20, 40, 20);
      spotLight.castShadow = true;
      scene.add(spotLight);

      // Personnage pixel
      player = new THREE.Group();

      const headGeo = new THREE.BoxGeometry(2, 2, 2);
      const skinMat = new THREE.MeshStandardMaterial({color: 0xffdbac});
      const head = new THREE.Mesh(headGeo, skinMat);
      head.position.set(0, 7, 0);
      player.add(head);

      const hairMat = new THREE.MeshStandardMaterial({color: 0x4b2e0c});
      const hairBack = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.5, 2.2), hairMat);
      hairBack.position.set(0, 7, -0.7);
      player.add(hairBack);
      const hairTop = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 2.2), hairMat);
      hairTop.position.set(0, 8.2, 0);
      player.add(hairTop);

      const eyeGeo = new THREE.BoxGeometry(0.4, 0.3, 0.1);
      const eyeMat = new THREE.MeshStandardMaterial({color: 0x000000});
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.5, 7.3, 1.01);
      player.add(leftEye);
      const rightEye = leftEye.clone();
      rightEye.position.x = 0.5;
      player.add(rightEye);

      const bodyGeo = new THREE.BoxGeometry(3, 5, 2);
      const bodyMat = new THREE.MeshStandardMaterial({color: 0x0033cc});
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 3.5, 0);
      player.add(body);

      const armGeo = new THREE.BoxGeometry(1, 4, 1);
      const armMat = new THREE.MeshStandardMaterial({color: 0x002299});
      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-2, 5, 0);
      player.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(2, 5, 0);
      player.add(rightArm);

      const legGeo = new THREE.BoxGeometry(1, 3, 1);
      const legMat = new THREE.MeshStandardMaterial({color: 0x001166});
      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.7, 1, 0);
      player.add(leftLeg);
      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.7, 1, 0);
      player.add(rightLeg);

      player.position.set(0, 1.5, 0);
      scene.add(player);

      createPlatform(0, 0, 0, 0xff3300);
      createPlatform(8, 0, -10, 0xff4400);
      createPlatform(-7, 0, -20, 0xff2200);
      createCoin(8, 2, -10);
      createCoin(-7, 2, -20);

      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
    }

    function createPlatform(x, y, z, color=0x550000) {
      const geometry = new THREE.BoxGeometry(10, 1, 10);
      const material = new THREE.MeshStandardMaterial({color, emissive: 0xaa2200, emissiveIntensity: 0.6});
      const platform = new THREE.Mesh(geometry, material);
      platform.position.set(x, y, z);
      platform.receiveShadow = true;
      scene.add(platform);
      platforms.push(platform);
    }

    function createCoin(x, y, z) {
      const geometry = new THREE.CylinderGeometry(0.7, 0.7, 0.3, 16);
      const material = new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.7});
      const coin = new THREE.Mesh(geometry, material);
      coin.position.set(x, y, z);
      coin.rotation.x = Math.PI / 2;
      scene.add(coin);
      coins.push(coin);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e) {
      if (e.key === 'ArrowLeft') moveLeft = true;
      if (e.key === 'ArrowRight') moveRight = true;
      if ((e.key === 'ArrowUp' || e.key === ' ') && !jumping) {
        velocityY = jumpPower;
        jumping = true;
      }
    }

    function onKeyUp(e) {
      if (e.key === 'ArrowLeft') moveLeft = false;
      if (e.key === 'ArrowRight') moveRight = false;
    }

    function animate() {
      if (moveLeft) player.position.x -= 0.2;
      if (moveRight) player.position.x += 0.2;
      if (player.position.x < -15) player.position.x = -15;
      if (player.position.x > 15) player.position.x = 15;

      velocityY += gravity * 0.1;
      player.position.y += velocityY * 0.1;

      jumping = true;
      for (let plat of platforms) {
        const {x: px, z: pz} = plat.position;
        const pw = 5, pd = 5;
        if (player.position.x > px - pw && player.position.x < px + pw &&
            player.position.z > pz - pd && player.position.z < pz + pd) {
          let top = plat.position.y + 0.5;
          if (player.position.y <= top + 1.5 && player.position.y >= top) {
            player.position.y = top + 1.5;
            velocityY = 0;
            jumping = false;
          }
        }
      }

      for (let i = coins.length - 1; i >= 0; i--) {
        let c = coins[i];
        if (player.position.distanceTo(c.position) < 2) {
          scene.remove(c);
          coins.splice(i, 1);
          score++;
          document.getElementById('score').textContent = score;
        }
      }

      if (player.position.y < -10) {
        document.getElementById('info').textContent = `Game Over ! Pièces ramassées : ${score}`;
        return;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
  }
</script>
</body>
</html>
